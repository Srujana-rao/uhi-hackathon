backend/./package.json:
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon src/server.js",
    "start": "node src/server.js",
    "seed": "node src/db/seed/seed.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^9.0.0",
    "multer": "^2.0.2"
  },
  "devDependencies": {
    "nodemon": "^3.1.11"
  }
}



backend/./.env.example:
# Backend / root .env.example
# ===========================
# Server Configuration
# ===========================
PORT=4000
NODE_ENV=development
AI_MODE=mock

# ===========================
# Database
# ===========================
MONGO_URI="mongodb+srv://<username>:<password>@uhi-hackathon-cluster.cjez6eb.mongodb.net/uhi-hackathon?retryWrites=true&w=majority"

# ===========================
# Security Keys
# ===========================
JWT_SECRET=<your-jwt-secret>
OPENAI_API_KEY=<your-openai-api-key>
ADMIN_API_KEY=<your-admin-api-key>

# ===========================
# Frontend
# ===========================
FRONTEND_URL=http://localhost:5173

# ===========================
# Feature Flags
# ===========================
ALLOW_ADMIN_CREATE=false




backend/./backend-architecture.md:
# UHI ‚Äî Backend Architecture & Frontend Integration Guide

**(Complete, actionable Markdown, ready to save as `backend-architecture.md`)**

> Audience: Frontend engineers, new backend contributors, reviewers.
> Goal: everything needed to run, test and integrate with the backend ‚Äî endpoints, data models, auth flows, example `curl` tests, and a description of server-side behaviour (single-step user creation, role protections, LHP access rules).

---

## Table of contents

1. [Quick system summary](#quick-system-summary)
2. [How to run locally (install, env, start)](#how-to-run-locally)
3. [Seed data (what's preloaded)](#seed-data)
4. [Auth & tokens (how login works)](#auth--tokens)
5. [Routes ‚Äî quick reference](#routes---quick-reference)
6. [Models (shape & meaning)](#models)
7. [Single-step user creation (contract + server behaviour)](#single-step-user-creation)
8. [Role-based access: rules & examples](#role-based-access-rules)
9. [Protected data redaction rules (what frontend receives)](#protected-data-redaction)
10. [LHP access check (doctor-only during consultations) ‚Äî where to add server check](#lhp-access-check)
11. [Common integration `curl` tests (copy/paste) ‚Äî login, create, fetch, update](#curl-tests)
12. [Troubleshooting & tips](#troubleshooting--tips)
13. [Next steps / deliverables for frontend](#next-steps)

---

## 1) Quick system summary

* Backend: Node.js + Express + Mongoose
* DB: MongoDB (Atlas recommended for dev); connection in `backend/.env` (`MONGO_URI`)
* All APIs mounted under: `http://localhost:4000/api/*`
* Auth: JWT (HMAC using `JWT_SECRET`); token contains `{ sub, role, name, ... }`
* Primary domain entities: `User`, `Doctor`, `Patient`, `Staff`, `ConsultationEvent`, `PrescriptionEvent`, `LHP` (Longitudinal Health Profile)
* Admin creation allowed is controlled by env (e.g. `ALLOW_ADMIN_CREATE=false` recommended)

---

## 2) How to run locally

1. Clone repo and `cd backend`
2. `npm install`
3. Create `.env` from `.env.example`. Minimal required in `.env`:

   ```
   PORT=4000
   MONGO_URI=<your_mongo_connection_string>
   JWT_SECRET=<long-random-secret>
   NODE_ENV=development
   AI_MODE=mock
   ADMIN_API_KEY=<if used - optional>
   FRONTEND_URL=http://localhost:5173
   ALLOW_ADMIN_CREATE=false
   ```
4. Seed the DB (optional): `npm run seed` (script exists in `package.json`).
5. Start server (dev): `npm run dev` (nodemon)
   Server listens on `http://localhost:4000` by default.

---

## 3) Seed data (what's preloaded)

The repository contains seed files under `src/db/seed/`. Typical items seeded in the provided project:

* 3 doctors (with `_id`s present)
* 3 patients
* 3 staff
* Several consultations + prescriptions
* 1 Admin **created by you** during setup (seed does not put admin unless you create)
* 9 default users (doctors/patients/staff) from `users.seed.json`

You can inspect `src/db/seed/*.seed.json`. Run the seeder with `npm run seed`.

---

## 4) Auth & tokens (how login works)

**Login endpoint**

```
POST /api/auth/login
Content-Type: application/json
Body: { "email": "...", "password": "..." }
```

**Response**

```json
{
  "token": "<JWT>",
  "role": "doctor|patient|staff|admin",
  "userId": "<user-id>"
}
```

* Frontend stores the JWT (e.g. `localStorage.setItem('token', token)`) and sends `Authorization: Bearer <token>` in subsequent requests.
* JWT payload contains `sub` (user id), `role`, `name` and can include `doctorId`, `patientId`, `staffId` (server may include these so clients can know their linked domain id).

**Note:** Admins should *not* be creatable from public endpoints ‚Äî server-side enforces that (see `ALLOW_ADMIN_CREATE`).

---

## 5) Routes ‚Äî quick reference

**Auth**

* `POST /api/auth/login` ‚Äî get JWT

**Users**

* `GET /api/users` ‚Äî admin only (list users)
* `GET /api/users/:id` ‚Äî role-protected & redacted based on requester
* `POST /api/users` ‚Äî admin only; supports **single-step** creation (see below)
* `PUT /api/users/:id` ‚Äî admin or user themself
* `DELETE /api/users/:id` ‚Äî admin only

**Domain**

* `GET /api/doctors`
* `GET /api/patients`
* `GET /api/staff`

**Consultations / LHP / Prescriptions**

* `GET /api/consultations` etc.
* `GET /api/lhp/:patientId` ‚Äî LHP suggestions / data for a patient (access controlled; see LHP access rules)

---

## 6) Models (shape & meaning)

### User

```js
{
  email: String,            // unique, required
  passwordHash: String,     // hashed
  role: 'admin'|'doctor'|'patient'|'staff',
  doctorId: ObjectId?,      // when role==='doctor'
  patientId: ObjectId?,     // when role==='patient'
  staffId: ObjectId?,       // when role==='staff'
  name: String,
  createdAt, updatedAt
}
```

### Doctor

```js
{
  name: String (required),
  specialization: String,
  registrationNumber: String,
  createdAt, updatedAt
}
```

### Patient

```js
{
  patientCode: String (unique, required),
  name: String (required),
  age: Number,
  gender: String,
  phone: String,
  createdAt, updatedAt
}
```

### Staff

```js
{
  name: String (required),
  roleDescription: String
}
```

---

## 7) Single-step user creation ‚Äî API contract & server behaviour

**Endpoint (admin-only)**

```
POST /api/users
Authorization: Bearer <ADMIN_JWT>
Content-Type: application/json
```

**Payload (examples)**

*Create a doctor in one request (single-step)*

```json
{
  "email": "doctor-auto@test.com",
  "password": "password123",
  "name": "Dr Auto",
  "role": "doctor",
  "doctor": {
    "name": "Dr Auto",
    "specialization": "Cardio",
    "registrationNumber": "REG-AUTO-01"
  }
}
```

*Create a patient in one request*

```json
{
  "email": "patient-auto@test.com",
  "password": "password123",
  "name": "Patient Auto",
  "role": "patient",
  "patient": {
    "patientCode": "P-0005",
    "name": "Patient Auto",
    "age": 30,
    "gender": "F",
    "phone": "9876500005"
  }
}
```

**Server behaviour**

* If `role` === `doctor` and `doctor` object exists: create `Doctor` doc and use its `_id` as `doctorId` on the `User`.
* Similarly for `patient` and `staff`.
* Password is hashed (bcrypt) and never returned.
* The whole operation tries to run in a transaction (if supported) or will rollback created domain doc(s) if user creation fails.

**Response**

* `201 Created` with created `User` (no `passwordHash`) and `doctorId` / `patientId` / `staffId` populated.

**Why single-step?**

* Keeps frontend simpler: a single API call creates both the domain profile and the login account, keeping references consistent.

---

## 8) Role-based access rules (server enforced)

* `POST /api/users` ‚Äî **admin only** (server verifies `req.user.role==='admin'`).

  * Additionally the server blocks creation of `role: 'admin'` unless `ALLOW_ADMIN_CREATE=true` (protects accidental admin creation).
* `GET /api/users` ‚Äî admin only.
* `GET /api/users/:id` ‚Äî allowed to:

  * admin (full), or
  * the user themself (full), or
  * doctor requesting a patient (redacted fields only, see below) if the doctor is permitted (consultation relation can be verified).
* `PUT /api/users/:id` ‚Äî admin or the user themself.
* `DELETE /api/users/:id` ‚Äî admin only.
* LHP access:

  * patient themselves ‚Äî allowed
  * staff ‚Äî allowed with role-checks
  * doctor ‚Äî allowed only if doctor treated patient (the server should look for a `ConsultationEvent` linking `doctorId` and `patientId`).

---

## 9) Protected data redaction rules

The server returns redacted views for non-authorized requesters.

**Logic (summary)**

* `admin` ‚Üí sees everything (full user object).
* `owner` (user requesting their own record) ‚Üí sees everything.
* `doctor` requesting a `patient` ‚Üí sees limited demographic/contact info: `_id`, `role`, `name`, `patientId`, `phone`, `age`, `gender`, `createdAt`. **Full LHP is not returned here unless doctor is in consultation** and further checks passed.
* `staff` ‚Üí minimal public info: `_id`, `role`, `name`.
* `other roles` ‚Üí minimal public info.

This redaction is enforced in `users.controller` before sending the response.

---

## 10) LHP access check ‚Äî where to add the doctor-consultation check

Add the following logic at the beginning of `lhp.controller.getLhpForPatient` (or inside the LHP service) to enforce that a doctor can only access a patient's full LHP if they have a consultation with that patient:

```js
// backend/src/modules/lhp/lhp.controller.js (pseudo-ready code insertion)
const ConsultationEvent = require('../../db/models/ConsultationEvent'); // adjust path if needed

exports.getLhpForPatient = async (req, res) => {
  const { patientId } = req.params;
  
  // If requester is a doctor, ensure doctor treated this patient
  if (req.user && req.user.role === 'doctor') {
    const consultation = await ConsultationEvent.findOne({
      doctorId: req.user.doctorId,
      patientId
    }).lean();
    if (!consultation) {
      return res.status(403).json({ error: 'Doctor cannot access this LHP' });
    }
  }

  // Proceed to fetch LHP now
  const data = await svc.getForPatient(patientId);
  res.json(data);
};
```

**Note:** This must be done before returning full LHP content.

---

## 11) `curl` tests ‚Äî copy/paste validated examples

> Replace placeholders before running: `<ADMIN_EMAIL>`, `<ADMIN_PWD>`, `<JWT_TOKEN>`, `<PATIENT_USER_ID>`, etc.

### 11.1 Login as admin and capture token

```bash
curl -s -X POST http://localhost:4000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@test.com","password":"admin123"}' | jq
```

Or store token:

```bash
TOKEN=$(curl -s -X POST http://localhost:4000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@test.com","password":"admin123"}' | jq -r .token)
echo "$TOKEN"
```

### 11.2 Create a new doctor (single-step) ‚Äî admin only

```bash
curl -i -X POST http://localhost:4000/api/users \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "email":"doctor-auto@test.com",
    "password":"password123",
    "name":"Dr Auto",
    "role":"doctor",
    "doctor": {
      "name": "Dr Auto",
      "specialization": "Cardio",
      "registrationNumber": "REG-AUTO-01"
    }
  }'
```

Expected: `201 Created` and JSON with `doctorId` and user `_id`.

### 11.3 Create a patient (single-step)

```bash
curl -i -X POST http://localhost:4000/api/users \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "email":"patient-auto@test.com",
    "password":"password123",
    "name":"Patient Auto",
    "role":"patient",
    "patient": {
      "patientCode":"P-AUTO-01",
      "name":"Patient Auto",
      "age": 28,
      "gender":"F",
      "phone":"9876501234"
    }
  }'
```

### 11.4 List users (admin only)

```bash
curl -s -H "Authorization: Bearer $TOKEN" http://localhost:4000/api/users | jq
```

### 11.5 Doctor login & fetching a patient (redacted view)

* Login as a doctor (use earlier created doctor credentials):

```bash
DOC_TOKEN=$(curl -s -X POST http://localhost:4000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"doctor1@test.com","password":"password123"}' | jq -r .token)
```

* Attempt to GET a patient user record:

```bash
curl -s -H "Authorization: Bearer $DOC_TOKEN" http://localhost:4000/api/users/<patient-user-id> | jq
```

* If the doctor **has** a consultation with that patient, server responds with limited but actionable fields (`phone`, `age`, `gender`). Otherwise `403` may be returned for restricted LHP endpoints.

### 11.6 Patient login & own profile

```bash
PAT_TOKEN=$(curl -s -X POST http://localhost:4000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"patient1@test.com","password":"password123"}' | jq -r .token)

curl -s -H "Authorization: Bearer $PAT_TOKEN" http://localhost:4000/api/users/<their-user-id> | jq
```

### 11.7 Fetch LHP for patient (doctor allowed only if consulted)

```bash
curl -s -H "Authorization: Bearer $DOC_TOKEN" http://localhost:4000/api/lhp/<patientId> | jq
```

---

## 12) Troubleshooting & tips

* If `npm run seed` errors with `MongoParseError` then there may be legacy options embedded in your URI; ensure you use a current MONGO_URI format.
* If `require()` of a `routes` file throws `argument handler must be a function`, check that the module exports an Express `router` (i.e. `module.exports = router`) and not an object.
* If you get `app.use() requires a middleware function`, inspect `app.js` to confirm all `app.use(...)` arguments are functions or routers.
* `ALLOW_ADMIN_CREATE=false` prevents accidental admin creation ‚Äî set it to `true` only when intentionally creating admin users (and prefer seeding).
* JWT secret should be long and stored securely. Avoid checking `.env` into source control.

---

## 13) Next steps (for frontend team)

1. Implement login UI (`/auth/login`) and store token. On login, parse JWT to determine `role` and redirect accordingly.
2. Admin pages:

   * User management UI that uses the single-step `POST /api/users` to create users with embedded `doctor|patient|staff` object.
   * List users (`GET /api/users`) only visible to admin.
3. Doctor UI:

   * List consultations, links to patient pages.
   * When navigating to a patient, fetch `GET /api/users/:id` (doctor sees redacted info unless they have an active consultation).
   * LHP pages call `GET /api/lhp/:patientId` and show a message if 403 (doctor not authorized).
4. Patient UI:

   * Own profile (edit), timeline, LHP read.
5. Error handling: capture `401/403` and redirect to login or show proper messages.
6. Use the `doctorId`/`patientId` returned in user creation to link domain pages (E.g. `patientId` used to fetch LHP).

---

## Appendix A ‚Äî Key server snippets (actual file excerpts you should keep / review)

> The following are essential code shapes to keep the contract stable. Keep them in repo docs for quick reference.

### `users.service.create` (core single-step creation logic ‚Äî simplified excerpt)

```js
// core ideas (full implementation lives in src/modules/users/users.service.js)
const mongoose = require('mongoose');
const User = require('../../db/models/User');
const Doctor = require('../../db/models/Doctor');
const Patient = require('../../db/models/Patient');
const Staff = require('../../db/models/Staff');
const bcrypt = require('bcryptjs');

exports.create = async (data) => {
  // validate email & password
  const existing = await User.findOne({ email: data.email });
  if (existing) throw new Error('email already exists');

  const session = await mongoose.startSession();
  let usingTransaction = false;
  try {
    session.startTransaction();
    usingTransaction = true;
  } catch (e) { /* fallback to no tx */ }

  const createdDomain = { doctorId: null, patientId: null, staffId: null };

  try {
    // create domain doc if requested
    if (data.role === 'doctor') {
      // create new Doctor from data.doctor
      const created = await Doctor.create([{
        name: data.doctor.name,
        specialization: data.doctor.specialization,
        registrationNumber: data.doctor.registrationNumber
      }], usingTransaction ? { session } : undefined);
      createdDomain.doctorId = created[0]._id;
    }
    // similarly for patient/staff...

    const passwordHash = await bcrypt.hash(data.password, 10);

    const userDoc = {
      email: data.email,
      passwordHash,
      role: data.role,
      name: data.name || '',
      doctorId: createdDomain.doctorId || undefined,
      patientId: createdDomain.patientId || undefined,
      staffId: createdDomain.staffId || undefined
    };

    const createdUsers = await User.create([userDoc], usingTransaction ? { session } : undefined);
    const createdUser = Array.isArray(createdUsers) ? createdUsers[0] : createdUsers;

    if (usingTransaction && session) {
      await session.commitTransaction();
    }

    const out = createdUser.toObject();
    delete out.passwordHash;
    return out;
  } catch (err) {
    if (usingTransaction && session) {
      await session.abortTransaction();
    } else {
      // manual rollback of created domain docs, if any
      if (createdDomain.doctorId) await Doctor.findByIdAndDelete(createdDomain.doctorId).exec();
      // patient/staff similarly...
    }
    throw err;
  } finally {
    if (session) session.endSession();
  }
};
```

### `users.controller` (redaction & enforcement ‚Äî excerpt of recommended structure)

```js
// in src/modules/users/users.controller.js
const service = require('./users.service');

function redactForRequester(targetUser, requester) {
  if (!requester) return { _id: targetUser._id, role: targetUser.role, name: targetUser.name || null };
  if (requester.role === 'admin') return targetUser;
  if (String(requester.sub) === String(targetUser._id)) return targetUser;

  if (requester.role === 'doctor' && targetUser.role === 'patient') {
    return {
      _id: targetUser._id,
      role: targetUser.role,
      name: targetUser.name || null,
      patientId: targetUser.patientId || null,
      phone: targetUser.phone || null,
      age: targetUser.age || null,
      gender: targetUser.gender || null,
      createdAt: targetUser.createdAt
    };
  }

  if (requester.role === 'staff') {
    return { _id: targetUser._id, role: targetUser.role, name: targetUser.name || null };
  }

  return { _id: targetUser._id, role: targetUser.role, name: targetUser.name || null };
}

exports.getUser = async (req, res) => {
  // auth middleware must populate req.user
  const target = await service.getById(req.params.id);
  if (!target) return res.status(404).json({ error: 'Not found' });

  const out = redactForRequester(target, req.user);
  res.json(out);
};
```

---

## Appendix B ‚Äî Checklist before handing to frontend team

* [ ] `JWT_SECRET` set in `.env` and shared with backend team only
* [ ] `ALLOW_ADMIN_CREATE=false` in `.env` for non-production safety
* [ ] Seeder run and `admin@test.com` created (or an admin created manually)
* [ ] Verify `POST /api/users` works as single-step user+domain creation with sample `curl`
* [ ] LHP controller contains doctor verification snippet (consultation check) shown earlier
* [ ] `authMiddleware` attaches `req.user` for role checks (ensure fields `sub`, `role`, `doctorId` etc are present)

---

## Appendix C ‚Äî Example dev workflow (quick)

1. `npm run dev`
2. `TOKEN=$(curl -s -X POST http://localhost:4000/api/auth/login -H "Content-Type: application/json" -d '{"email":"admin@test.com","password":"admin123"}' | jq -r .token)`
3. Create user: run `curl -i -X POST http://localhost:4000/api/users` (use payload examples above).
4. Frontend: login, store token, call `/api/users` endpoints as per role.

---

## Final notes / policy decisions embedded

* Admin creation is disabled by default (`ALLOW_ADMIN_CREATE=false`); only seeded or manual (db) creation should be used for the first admin.
* Single-step user creation keeps frontend simple and reduces race conditions ‚Äî server handles domain doc creation and linking.
* Doctor access to patient LHP is gated by consultation linkage to protect patient privacy.

---



backend/./src/middleware/authMiddleware.js:
// backend/src/middleware/authMiddleware.js
const jwt = require('jsonwebtoken');

function parseTokenFromHeader(req) {
  const h = req.headers.authorization || '';
  if (!h.startsWith('Bearer ')) return null;
  return h.slice(7).trim();
}

/**
 * requireAuth middleware
 * - verifies JWT
 * - attaches req.user = { sub, role, name, doctorId, patientId, staffId }
 * - sends 401 on invalid/missing token
 */
function requireAuth(req, res, next) {
  try {
    const token = parseTokenFromHeader(req);
    if (!token) return res.status(401).json({ error: 'Unauthorized: no token' });

    const payload = jwt.verify(token, process.env.JWT_SECRET);
    // payload should contain sub, role, name, maybe doctorId/patientId/staffId
    const user = {
      sub: payload.sub,
      role: payload.role,
      name: payload.name,
      doctorId: payload.doctorId,
      patientId: payload.patientId,
      staffId: payload.staffId
    };
    req.user = user;
    return next();
  } catch (err) {
    return res.status(401).json({ error: 'Unauthorized: invalid token' });
  }
}

/**
 * requireRole(roleOrArray)
 * returns middleware that ensures req.user.role === role (or included in array)
 */
function requireRole(roleOrArray) {
  const roles = Array.isArray(roleOrArray) ? roleOrArray : [roleOrArray];
  return (req, res, next) => {
    if (!req.user) return res.status(401).json({ error: 'Unauthorized' });
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    return next();
  };
}

module.exports = { requireAuth, requireRole };



backend/./src/middleware/errorHandler.js:
// backend/src/middleware/errorHandler.js
// Central error handler middleware for Express

function errorHandler(err, req, res, next) {
  // log to console for dev
  console.error('‚úñ errorHandler:', err && err.stack ? err.stack : err);

  // if headers already sent, delegate to default Express handler
  if (res.headersSent) {
    return next(err);
  }

  const status = err && err.status ? err.status : 500;
  const message = err && err.message ? err.message : 'Internal Server Error';

  // minimal error payload; expand as needed for debugging (but avoid leaking secrets)
  res.status(status).json({
    error: message,
    // include stack only in development
    ...(process.env.NODE_ENV === 'development' ? { stack: err && err.stack } : {})
  });
}

module.exports = { errorHandler };



backend/./src/middleware/roleMiddleware.js:
const jwt = require('jsonwebtoken');

function requireRole(role) {
  return function (req, res, next) {
    const auth = req.headers.authorization;
    if (!auth) return res.status(401).json({ error: 'No token provided' });
    const token = auth.replace('Bearer ', '');
    try {
      const payload = jwt.verify(token, process.env.JWT_SECRET);
      if (payload.role !== role) return res.status(403).json({ error: 'Forbidden' });
      req.user = payload;
      next();
    } catch (err) {
      return res.status(401).json({ error: 'Invalid token' });
    }
  };
}

module.exports = { requireRole };



backend/./src/middleware/uploadMiddleware.js:



backend/./src/config/logger.js:



backend/./src/config/index.js:
// backend/src/config/index.js
require('dotenv').config();

module.exports = {
  mongoUri: process.env.MONGO_URI || process.env.MONGOURL || null,
  frontEndUrl: process.env.FRONTEND_URL || 'http://localhost:5173'
};



backend/./src/server.js:
require('dotenv').config();
const app = require('./app');
const { connectDB } = require('./db');

const PORT = process.env.PORT || 4000;

async function start() {
  await connectDB();
  app.listen(PORT, () => {
    console.log(`Backend running on http://localhost:${PORT} (NODE_ENV=${process.env.NODE_ENV})`);
  });
}

start().catch(err => {
  console.error('Failed to start server', err);
  process.exit(1);
});



backend/./src/uploads/images/prescription3.png:



backend/./src/uploads/images/prescription2.png:



backend/./src/uploads/images/prescription1.png:



backend/./src/uploads/audio/consult2.mp3:



backend/./src/uploads/audio/consult3.mp3:



backend/./src/uploads/audio/consult1.mp3:



backend/./src/utils/constants.js:



backend/./src/utils/responseHelpers.js:



backend/./src/utils/fileStorage.js:



backend/./src/db/seed/lhpSuggestions.seed.json:



backend/./src/db/seed/lhpAllergies.seed.txt:
[
  {
    "_id": "6778c1e4f1f0a9a8f0000082",
    "patientId": "6778c1e4f1f0a9a8f0000003",
    "label": "Suspected contact allergy (soap)",
    "notes": "AI-suggested allergy from rash consult; explicitly ignored by doctor.",
    "status": "IGNORED_BY_DOCTOR",
    "source": {
      "type": "CONSULTATION",
      "eventId": "6778c1e4f1f0a9a8f0000043",
      "suggestionId": "6778c1e4f1f0a9a8f0000063"
    },
    "createdByUserId": "6778c1e4f1f0a9a8f0000033",
    "createdAt": "2025-02-01T10:33:00Z",
    "updatedAt": "2025-02-01T10:33:00Z"
  }
]



backend/./src/db/seed/lhpChronicConditions.seed.json:



backend/./src/db/seed/patients.seed.json:
[
  {
    "_id": "6778c1e4f1f0a9a8f0000001",
    "patientCode": "P-0001",
    "name": "Arjun Mehta",
    "age": 32,
    "gender": "M",
    "phone": "9876100001",
    "createdAt": "2025-02-01T10:00:00Z",
    "updatedAt": "2025-02-01T10:00:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000002",
    "patientCode": "P-0002",
    "name": "Isha Reddy",
    "age": 27,
    "gender": "F",
    "phone": "9876100002",
    "createdAt": "2025-02-01T10:01:00Z",
    "updatedAt": "2025-02-01T10:01:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000003",
    "patientCode": "P-0003",
    "name": "Rohit Sharma",
    "age": 45,
    "gender": "M",
    "phone": "9876100003",
    "createdAt": "2025-02-01T10:02:00Z",
    "updatedAt": "2025-02-01T10:02:00Z"
  }
]



backend/./src/db/seed/prescriptions.seed.json:
[
  {
    "_id": "6778c1e4f1f0a9a8f0000051",
    "patientId": "6778c1e4f1f0a9a8f0000001",
    "doctorId": "6778c1e4f1f0a9a8f0000011",
    "createdByRole": "doctor",
    "createdByUserId": "6778c1e4f1f0a9a8f0000031",
    "linkedConsultationId": "6778c1e4f1f0a9a8f0000041",
    "imagePath": "/uploads/images/prescription1.png",
    "rawOcrText": "Tab Paracetamol 500mg ‚Äì 1 tablet TID for 3 days",
    "meds": {
      "current": {
        "medications": [
          {
            "name": "Paracetamol",
            "dosage": "500mg",
            "frequency": "TID",
            "route": "oral",
            "duration": "3 days",
            "instructions": "Take after food. Do not exceed 3g/day.",
            "isCurrent": true
          }
        ],
        "editedByUserId": "6778c1e4f1f0a9a8f0000031",
        "editedByRole": "doctor",
        "editedAt": "2025-02-01T10:13:00Z"
      },
      "history": [
        {
          "medications": [
            {
              "name": "Paracetamol",
              "dosage": "500mg",
              "frequency": "BID",
              "route": "oral",
              "duration": "2 days",
              "instructions": "Initial plan, then adjusted.",
              "isCurrent": false
            }
          ],
          "editedByUserId": "6778c1e4f1f0a9a8f0000031",
          "editedByRole": "doctor",
          "editedAt": "2025-02-01T10:12:00Z"
        }
      ]
    },
    "status": "VERIFIED_DOCTOR",
    "createdAt": "2025-02-01T10:11:00Z",
    "updatedAt": "2025-02-01T10:13:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000052",
    "patientId": "6778c1e4f1f0a9a8f0000002",
    "doctorId": "6778c1e4f1f0a9a8f0000012",
    "createdByRole": "doctor",
    "createdByUserId": "6778c1e4f1f0a9a8f0000032",
    "linkedConsultationId": "6778c1e4f1f0a9a8f0000042",
    "imagePath": "/uploads/images/prescription2.png",
    "rawOcrText": "Syrup Paracetamol 250mg/5ml ‚Äì 10ml QID if fever.",
    "meds": {
      "current": {
        "medications": [
          {
            "name": "Paracetamol Syrup",
            "dosage": "250mg/5ml",
            "frequency": "QID",
            "route": "oral",
            "duration": "3 days",
            "instructions": "10ml if fever >100¬∞F; max 4 doses/day.",
            "isCurrent": true
          }
        ],
        "editedAt": "2025-02-01T10:16:00Z"
      },
      "history": []
    },
    "status": "UNVERIFIED",
    "createdAt": "2025-02-01T10:16:00Z",
    "updatedAt": "2025-02-01T10:16:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000053",
    "patientId": "6778c1e4f1f0a9a8f0000003",
    "doctorId": "6778c1e4f1f0a9a8f0000013",
    "staffId": "6778c1e4f1f0a9a8f0000021",          
    "createdByRole": "doctor",
    "createdByUserId": "6778c1e4f1f0a9a8f0000033",  
    "linkedConsultationId": "6778c1e4f1f0a9a8f0000043",
    "imagePath": "/uploads/images/prescription3.png",
    "rawOcrText": "Tab Loratadine 10mg OD and topical steroid cream BID.",
    "meds": {
      "current": {
        "medications": [
          {
            "name": "Loratadine",
            "dosage": "10mg",
            "frequency": "OD",
            "route": "oral",
            "duration": "7 days",
            "instructions": "Take at night.",
            "isCurrent": true,
            "dispensedByStaffId": "6778c1e4f1f0a9a8f0000021",
            "dispensedAt": "2025-02-01T10:22:30Z"
          },
          {
            "name": "Topical Steroid Cream",
            "dosage": "thin layer",
            "frequency": "BID",
            "route": "topical",
            "duration": "5 days",
            "instructions": "Apply on affected area only.",
            "isCurrent": true,
            "dispensedByStaffId": "6778c1e4f1f0a9a8f0000021",
            "dispensedAt": "2025-02-01T10:22:30Z"
          }
        ],
        "editedByUserId": "6778c1e4f1f0a9a8f0000037", 
        "editedByRole": "staff",
        "editedAt": "2025-02-01T10:22:00Z"
      },
      "history": [
        {
          "medications": [
            {
              "name": "Loratadine",
              "dosage": "10mg",
              "frequency": "OD",
              "route": "oral",
              "duration": "5 days",
              "instructions": "Initial shorter duration.",
              "isCurrent": false
            }
          ],
          "editedByUserId": "6778c1e4f1f0a9a8f0000033",
          "editedByRole": "doctor",
          "editedAt": "2025-02-01T10:20:00Z"
        }
      ]
    },
    "status": "VERIFIED_STAFF",
    "createdAt": "2025-02-01T10:19:00Z",
    "updatedAt": "2025-02-01T10:22:00Z"
  }
]



backend/./src/db/seed/lhpAllergies.seed.json:



backend/./src/db/seed/notifications.seed.json:



backend/./src/db/seed/doctors.seed.json:
[
  {
    "_id": "6778c1e4f1f0a9a8f0000011",
    "name": "Dr. Arvind Rao",
    "specialization": "Cardiology",
    "registrationNumber": "LICC1001",
    "createdAt": "2025-02-01T10:00:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000012",
    "name": "Dr. Shreya Banerjee",
    "specialization": "Neurology",
    "registrationNumber": "LICN1002",
    "createdAt": "2025-02-01T10:01:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000013",
    "name": "Dr. Priya Menon",
    "specialization": "Pediatrics",
    "registrationNumber": "LICP1003",
    "createdAt": "2025-02-01T10:02:00Z"
  }
]



backend/./src/db/seed/lhpCurrentMedications.seed.txt:
[
  {
    "_id": "6778c1e4f1f0a9a8f0000083",
    "patientId": "6778c1e4f1f0a9a8f0000002",
    "label": "Paracetamol Syrup 250mg/5ml QID",
    "notes": "From prescription PR0052; added to LHP after AI suggestion was accepted.",
    "status": "VERIFIED_DOCTOR",
    "source": {
      "type": "PRESCRIPTION",
      "eventId": "6778c1e4f1f0a9a8f0000052",
      "suggestionId": "6778c1e4f1f0a9a8f0000062"
    },
    "createdByUserId": "6778c1e4f1f0a9a8f0000032",
    "createdAt": "2025-02-01T10:31:00Z",
    "updatedAt": "2025-02-01T10:31:00Z"
  }
]



backend/./src/db/seed/lhpPastProcedures.seed.json:



backend/./src/db/seed/staff.seed.json:
[
  {
    "_id": "6778c1e4f1f0a9a8f0000021",
    "name": "Anita Pillai",
    "roleDescription": "Nurse",
    "createdAt": "2025-02-01T10:00:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000022",
    "name": "Rohit Malhotra",
    "roleDescription": "Pharmacist",
    "createdAt": "2025-02-01T10:01:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000023",
    "name": "Deepa Chatterjee",
    "roleDescription": "Front Desk Receptionist",
    "createdAt": "2025-02-01T10:02:00Z"
  }
]



backend/./src/db/seed/consultations.seed.json:
[
  {
    "_id": "6778c1e4f1f0a9a8f0000041",
    "patientId": "6778c1e4f1f0a9a8f0000001",
    "doctorId": "6778c1e4f1f0a9a8f0000011",
    "createdByRole": "patient",
    "createdByUserId": "6778c1e4f1f0a9a8f0000034",
    "audioPath": "/uploads/audio/consult1.mp3",
    "transcript": "Patient complains of headache and fatigue for 2 days.",
    "soap": {
      "current": {
        "subjective": "Headache and fatigue for 2 days. No vomiting or blurred vision.",
        "objective": "BP 120/80 mmHg, afebrile, neuro exam normal.",
        "assessment": "Tension-type headache; low suspicion for migraine.",
        "plan": "Paracetamol 500mg TID √ó 3 days; rest; hydration.",
        "editedByUserId": "6778c1e4f1f0a9a8f0000031",
        "editedByRole": "doctor",
        "editedAt": "2025-02-01T10:10:00Z"
      },
      "history": [
        {
          "subjective": "Mild headache since yesterday.",
          "objective": "Vitals stable.",
          "assessment": "Likely benign headache.",
          "plan": "Observation + hydration.",
          "editedByUserId": "6778c1e4f1f0a9a8f0000031",
          "editedByRole": "doctor",
          "editedAt": "2025-02-01T10:07:00Z"
        }
      ]
    },
    "status": "VERIFIED_DOCTOR",
    "prescriptionId": "6778c1e4f1f0a9a8f0000051",
    "createdAt": "2025-02-01T10:05:00Z",
    "updatedAt": "2025-02-01T10:10:00Z"  
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000042",
    "patientId": "6778c1e4f1f0a9a8f0000002",
    "doctorId": "6778c1e4f1f0a9a8f0000012",
    "createdByRole": "doctor",
    "createdByUserId": "6778c1e4f1f0a9a8f0000032",
    "audioPath": "/uploads/audio/consult2.mp3",
    "transcript": "Fever and dry cough for 3 days.",
    "soap": {
      "current": {
        "subjective": "Fever (100¬∞F) with dry cough for 3 days.",
        "objective": "RR 18, SpO2 99%, chest clear.",
        "assessment": "Viral upper respiratory tract infection.",
        "plan": "Paracetamol PRN; warm fluids; steam inhalation.",
        "editedAt": "2025-02-01T10:08:00Z"   
      },
      "history": []
    },
    "status": "UNVERIFIED",
    "prescriptionId": "6778c1e4f1f0a9a8f0000052",
    "createdAt": "2025-02-01T10:08:00Z",
    "updatedAt": "2025-02-01T10:08:00Z"      
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000043",
    "patientId": "6778c1e4f1f0a9a8f0000003",
    "doctorId": "6778c1e4f1f0a9a8f0000013",
    "createdByRole": "patient",
    "createdByUserId": "6778c1e4f1f0a9a8f0000036",
    "audioPath": "/uploads/audio/consult3.mp3",
    "transcript": "Itchy rash on forearms for one week.",
    "soap": {
      "current": {
        "subjective": "Itchy red rash on both forearms for 1 week.",
        "objective": "Papular erythematous rash, no discharge.",
        "assessment": "Contact dermatitis.",
        "plan": "Topical steroid cream BID; antihistamine HS; avoid irritant.",
        "editedByUserId": "6778c1e4f1f0a9a8f0000033",
        "editedByRole": "doctor",
        "editedAt": "2025-02-01T10:20:00Z"
      },
      "history": [
        {
          "subjective": "Rash worsening for 3 days.",
          "objective": "Mild redness, no systemic symptoms.",
          "assessment": "Suspected mild allergic reaction.",
          "plan": "Antihistamine trial for 2 days.",
          "editedByUserId": "6778c1e4f1f0a9a8f0000033",
          "editedByRole": "doctor",
          "editedAt": "2025-02-01T10:16:00Z"
        }
      ]
    },
    "status": "VERIFIED_DOCTOR",
    "prescriptionId": "6778c1e4f1f0a9a8f0000053",
    "createdAt": "2025-02-01T10:12:00Z",
    "updatedAt": "2025-02-01T10:20:00Z"  
  }
]



backend/./src/db/seed/lhpCurrentMedications.seed.json:



backend/./src/db/seed/users.seed.json:
[
  {
    "_id": "6778c1e4f1f0a9a8f0000099",
    "email": "admin@test.com",
    "passwordHash": "admin123",
    "role": "admin",
    "createdAt": "2025-02-01T10:00:00Z",
    "updatedAt": "2025-02-01T10:00:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000031",
    "email": "doctor1@test.com",
    "passwordHash": "password123",
    "role": "doctor",
    "doctorId": "6778c1e4f1f0a9a8f0000011",
    "createdAt": "2025-02-01T10:00:00Z",
    "updatedAt": "2025-02-01T10:00:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000032",
    "email": "doctor2@test.com",
    "passwordHash": "password123",
    "role": "doctor",
    "doctorId": "6778c1e4f1f0a9a8f0000012",
    "createdAt": "2025-02-01T10:01:00Z",
    "updatedAt": "2025-02-01T10:01:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000033",
    "email": "doctor3@test.com",
    "passwordHash": "password123",
    "role": "doctor",
    "doctorId": "6778c1e4f1f0a9a8f0000013",
    "createdAt": "2025-02-01T10:02:00Z",
    "updatedAt": "2025-02-01T10:02:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000034",
    "email": "patient1@test.com",
    "passwordHash": "password123",
    "role": "patient",
    "patientId": "6778c1e4f1f0a9a8f0000001",
    "createdAt": "2025-02-01T10:03:00Z",
    "updatedAt": "2025-02-01T10:03:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000035",
    "email": "patient2@test.com",
    "passwordHash": "password123",
    "role": "patient",
    "patientId": "6778c1e4f1f0a9a8f0000002",
    "createdAt": "2025-02-01T10:04:00Z",
    "updatedAt": "2025-02-01T10:04:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000036",
    "email": "patient3@test.com",
    "passwordHash": "password123",
    "role": "patient",
    "patientId": "6778c1e4f1f0a9a8f0000003",
    "createdAt": "2025-02-01T10:05:00Z",
    "updatedAt": "2025-02-01T10:05:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000037",
    "email": "staff1@test.com",
    "passwordHash": "password123",
    "role": "staff",
    "staffId": "6778c1e4f1f0a9a8f0000021",
    "createdAt": "2025-02-01T10:06:00Z",
    "updatedAt": "2025-02-01T10:06:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000038",
    "email": "staff2@test.com",
    "passwordHash": "password123",
    "role": "staff",
    "staffId": "6778c1e4f1f0a9a8f0000022",
    "createdAt": "2025-02-01T10:07:00Z",
    "updatedAt": "2025-02-01T10:07:00Z"
  },
  {
    "_id": "6778c1e4f1f0a9a8f0000039",
    "email": "staff3@test.com",
    "passwordHash": "password123",
    "role": "staff",
    "staffId": "6778c1e4f1f0a9a8f0000023",
    "createdAt": "2025-02-01T10:08:00Z",
    "updatedAt": "2025-02-01T10:08:00Z"
  }
]



backend/./src/db/seed/seed.js:
/**
 * backend/src/db/seed/seed.js
 * Robust seeder for the UHI hackathon.
 *
 * - Converts 24-hex string _id and reference fields to ObjectId
 * - Hashes plaintext passwords
 * - Uses ordered:false for resilience
 */

require('dotenv').config();
const mongoose = require('mongoose');
const path = require('path');
const fs = require('fs');
const bcrypt = require('bcryptjs');

const { mongoUri } = require('../../config'); // ensure this file exports mongoUri

// Models
const User = require('../models/User');
const Patient = require('../models/Patient');
const Doctor = require('../models/Doctor');
const Staff = require('../models/Staff');
const ConsultationEvent = require('../models/ConsultationEvent');
const PrescriptionEvent = require('../models/PrescriptionEvent');

const seedDir = __dirname;
const BCRYPT_SALT_ROUNDS = 10;

/** load seed JSON file (safe) */
function loadSeed(name) {
  try {
    const filePath = path.join(seedDir, `${name}.seed.json`);
    if (!fs.existsSync(filePath)) {
      console.warn(`‚ö†Ô∏è  Seed file not found: ${name}.seed.json (skipping)`);
      return [];
    }
    const raw = fs.readFileSync(filePath, 'utf-8').trim();
    if (!raw) {
      console.warn(`‚ö†Ô∏è  Seed file empty: ${name}.seed.json (skipping)`);
      return [];
    }
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) {
      console.warn(`‚ö†Ô∏è  Seed file ${name}.seed.json doesn't contain an array (skipping)`);
      return [];
    }
    console.log(`üìÑ Loaded ${parsed.length} records from ${name}.seed.json`);
    return parsed;
  } catch (err) {
    console.error(`‚ùå Error loading ${name}.seed.json: ${err.message}`);
    return [];
  }
}

/** Detect 24-hex ObjectId-like string */
function looksLikeObjectId(s) {
  return typeof s === 'string' && /^[0-9a-fA-F]{24}$/.test(s);
}

// -------- FIXED castIds FUNCTION (replace the old one completely) --------

function looksLikeObjectId(s) {
  return typeof s === 'string' && /^[0-9a-fA-F]{24}$/.test(s);
}

function toObjectId(val) {
  // Already an ObjectId? return as-is
  if (val && typeof val === 'object' && (val._bsontype === 'ObjectID' || (val.constructor && val.constructor.name === 'ObjectId'))) {
    return val;
  }
  // If it looks like a string ObjectId, convert properly using new
  if (looksLikeObjectId(val)) {
    return new mongoose.Types.ObjectId(val);
  }
  return val;
}

function castIds(obj) {
  if (!obj || typeof obj !== 'object') return obj;

  const idFields = [
    '_id', 'patientId', 'doctorId', 'staffId', 'createdByUserId',
    'linkedConsultationId', 'prescriptionId', 'dispensedByStaffId'
  ];

  const copy = { ...obj };

  // top-level ids
  for (const f of idFields) {
    if (copy[f]) {
      copy[f] = toObjectId(copy[f]);
    }
  }

  // SOAP current
  if (copy.soap?.current?.editedByUserId) {
    copy.soap.current.editedByUserId = toObjectId(copy.soap.current.editedByUserId);
  }

  // SOAP history
  if (Array.isArray(copy.soap?.history)) {
    copy.soap.history = copy.soap.history.map(h => ({
      ...h,
      editedByUserId: h.editedByUserId ? toObjectId(h.editedByUserId) : h.editedByUserId
    }));
  }

  // meds current
  if (copy.meds?.current?.editedByUserId) {
    copy.meds.current.editedByUserId = toObjectId(copy.meds.current.editedByUserId);
  }

  // meds history
  if (Array.isArray(copy.meds?.history)) {
    copy.meds.history = copy.meds.history.map(h => ({
      ...h,
      editedByUserId: h.editedByUserId ? toObjectId(h.editedByUserId) : h.editedByUserId
    }));
  }

  return copy;
}


async function prepareUsers(users) {
  return Promise.all(users.map(async u => {
    const copy = { ...u };

    // Convert _id if necessary (use toObjectId which uses `new`)
    if (copy._id) {
      copy._id = toObjectId(copy._id);
    }

    // Convert role-specific id refs to ObjectId too
    if (copy.doctorId) copy.doctorId = toObjectId(copy.doctorId);
    if (copy.patientId) copy.patientId = toObjectId(copy.patientId);
    if (copy.staffId) copy.staffId = toObjectId(copy.staffId);

    // If passwordHash looks like plain text (short), hash it
    if (copy.passwordHash && typeof copy.passwordHash === 'string') {
      const isProbablyPlain = copy.passwordHash.length < 30; // bcrypt hashes ~60 chars
      if (isProbablyPlain) {
        const hashed = await bcrypt.hash(copy.passwordHash, BCRYPT_SALT_ROUNDS);
        copy.passwordHash = hashed;
      }
    }
    return copy;
  }));
}


async function run() {
  try {
    if (!mongoUri && !process.env.MONGO_URI) {
      console.error('‚ùå No MONGO_URI in config or env. Set it and retry.');
      process.exit(1);
    }
    const uri = mongoUri || process.env.MONGO_URI;
    console.log('üîå Connecting to MongoDB:', uri);
    await mongoose.connect(uri);
    console.log('‚úÖ Connected to MongoDB');

    // Clear collections we will seed
    console.log('üßπ Clearing target collections (User, Patient, Doctor, Staff, ConsultationEvent, PrescriptionEvent)');
    await Promise.all([
      User.deleteMany({}),
      Patient.deleteMany({}),
      Doctor.deleteMany({}),
      Staff.deleteMany({}),
      ConsultationEvent.deleteMany({}),
      PrescriptionEvent.deleteMany({})
    ]);
    console.log('üßº Cleared.');

    // Load seed files
    const patientsRaw = loadSeed('patients');
    const doctorsRaw = loadSeed('doctors');
    const staffRaw = loadSeed('staff');
    const usersRaw = loadSeed('users');
    const consultationsRaw = loadSeed('consultations');
    const prescriptionsRaw = loadSeed('prescriptions');

    // Cast and prepare documents
    const patients = patientsRaw.map(p => castIds(p));
    const doctors = doctorsRaw.map(d => castIds(d));
    const staff = staffRaw.map(s => castIds(s));
    const users = await prepareUsers(usersRaw);
    const consultations = consultationsRaw.map(c => castIds(c));
    const prescriptions = prescriptionsRaw.map(p => castIds(p));

    // Insert with ordered:false so one bad doc doesn't stop the rest
    if (patients.length) {
      await Patient.insertMany(patients, { ordered: false });
      console.log(`‚úÖ Inserted ${patients.length} patients`);
    }
    if (doctors.length) {
      await Doctor.insertMany(doctors, { ordered: false });
      console.log(`‚úÖ Inserted ${doctors.length} doctors`);
    }
    if (staff.length) {
      await Staff.insertMany(staff, { ordered: false });
      console.log(`‚úÖ Inserted ${staff.length} staff`);
    }
    if (users.length) {
      await User.insertMany(users, { ordered: false });
      console.log(`‚úÖ Inserted ${users.length} users`);
    }
    if (consultations.length) {
      await ConsultationEvent.insertMany(consultations, { ordered: false });
      console.log(`‚úÖ Inserted ${consultations.length} consultations`);
    }
    if (prescriptions.length) {
      await PrescriptionEvent.insertMany(prescriptions, { ordered: false });
      console.log(`‚úÖ Inserted ${prescriptions.length} prescriptions`);
    }

    console.log('üå± Seed completed');
    await mongoose.disconnect();
    process.exit(0);
  } catch (err) {
    console.error('‚ùå Seed error:', err);
    process.exit(1);
  }
}

run();



backend/./src/db/seed/lhpPastProcedures.seed.txt:
[
  {
    "_id": "6778c1e4f1f0a9a8f0000084",
    "patientId": "6778c1e4f1f0a9a8f0000001",
    "label": "Appendectomy",
    "notes": "Appendix removal in 2020; no reported complications.",
    "status": "VERIFIED_DOCTOR",
    "source": {
      "type": "CONSULTATION",
      "eventId": "6778c1e4f1f0a9a8f0000041"
    },
    "createdByUserId": "6778c1e4f1f0a9a8f0000031",
    "createdAt": "2025-02-01T10:32:00Z",
    "updatedAt": "2025-02-01T10:32:00Z"
  }
]



backend/./src/db/seed/lhpChronicConditions.seed.txt:
[
  {
    "_id": "6778c1e4f1f0a9a8f0000081",
    "patientId": "6778c1e4f1f0a9a8f0000001",
    "label": "Hypertension",
    "notes": "Diagnosed 2 years ago; controlled on medication.",
    "status": "VERIFIED_DOCTOR",
    "source": {
      "type": "CONSULTATION",
      "eventId": "6778c1e4f1f0a9a8f0000041"
    },
    "createdByUserId": "6778c1e4f1f0a9a8f0000031",
    "createdAt": "2025-02-01T10:30:00Z",
    "updatedAt": "2025-02-01T10:30:00Z"
  }
]



backend/./src/db/index.js:
const mongoose = require('mongoose');

async function connectDB() {
  const uri = process.env.MONGO_URI;
  if (!uri) throw new Error('MONGO_URI not set in env');
  await mongoose.connect(uri);
  console.log('MongoDB connected');
}

module.exports = { connectDB };



backend/./src/db/models/Notification.js:



backend/./src/db/models/PrescriptionEvent.js:
// backend/src/db/models/PrescriptionEvent.js
const mongoose = require('mongoose');

const MedicationSchema = new mongoose.Schema({
  name: String,
  dosage: String,
  frequency: String,
  route: String,
  duration: String,
  instructions: String,
  startDate: Date,
  endDate: Date,
  isCurrent: Boolean,
  dispensedByStaffId: { type: mongoose.Schema.Types.ObjectId, ref: 'Staff' },
  dispensedAt: Date
}, { _id: false });

const MedsVersionSchema = new mongoose.Schema({
  medications: [MedicationSchema],
  editedByUserId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  editedByRole: String,
  editedAt: Date
}, { _id: false });

const PrescriptionEventSchema = new mongoose.Schema({
  patientId: { type: mongoose.Schema.Types.ObjectId, ref: 'Patient', required: true },
  doctorId: { type: mongoose.Schema.Types.ObjectId, ref: 'Doctor' },
  staffId: { type: mongoose.Schema.Types.ObjectId, ref: 'Staff' },
  createdByRole: String,
  createdByUserId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  linkedConsultationId: { type: mongoose.Schema.Types.ObjectId, ref: 'ConsultationEvent' },
  imagePath: String,
  rawOcrText: String,
  meds: {
    current: MedsVersionSchema,
    history: [MedsVersionSchema]
  },
  status: { type: String, default: 'UNVERIFIED' } // same statuses
}, { timestamps: true });

module.exports = mongoose.models.PrescriptionEvent || mongoose.model('PrescriptionEvent', PrescriptionEventSchema);



backend/./src/db/models/Patient.js:
// backend/src/db/models/Patient.js
const mongoose = require('mongoose');

const PatientSchema = new mongoose.Schema({
  patientCode: { type: String, required: true, unique: true },
  name: { type: String, required: true },
  age: { type: Number },
  gender: { type: String },
  phone: { type: String },
}, { timestamps: true });

module.exports = mongoose.models.Patient || mongoose.model('Patient', PatientSchema);



backend/./src/db/models/LhpAllergy.js:



backend/./src/db/models/User.js:
// backend/src/db/models/User.js
const mongoose = require('mongoose');

const UserSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true },
  passwordHash: { type: String, required: true },
  // INCLUDE 'admin' here so we can have admin users
  role: { type: String, enum: ['admin', 'doctor', 'patient', 'staff'], required: true },
  doctorId: { type: mongoose.Schema.Types.ObjectId, ref: 'Doctor' },
  patientId: { type: mongoose.Schema.Types.ObjectId, ref: 'Patient' },
  staffId: { type: mongoose.Schema.Types.ObjectId, ref: 'Staff' },
  name: { type: String }
}, { timestamps: true });

module.exports = mongoose.models.User || mongoose.model('User', UserSchema);



backend/./src/db/models/LhpCurrentMedication.js:



backend/./src/db/models/Staff.js:
// backend/src/db/models/Staff.js
const mongoose = require('mongoose');

const StaffSchema = new mongoose.Schema({
  name: { type: String, required: true },
  roleDescription: { type: String },
}, { timestamps: true });

module.exports = mongoose.models.Staff || mongoose.model('Staff', StaffSchema);



backend/./src/db/models/LhpChronicCondition.js:



backend/./src/db/models/LhpPastProcedure.js:



backend/./src/db/models/Doctor.js:
// backend/src/db/models/Doctor.js
const mongoose = require('mongoose');

const DoctorSchema = new mongoose.Schema({
  name: { type: String, required: true },
  specialization: { type: String },
  registrationNumber: { type: String },
}, { timestamps: true });

module.exports = mongoose.models.Doctor || mongoose.model('Doctor', DoctorSchema);



backend/./src/db/models/ConsultationEvent.js:
// backend/src/db/models/ConsultationEvent.js
const mongoose = require('mongoose');

const SoapVersionSchema = new mongoose.Schema({
  subjective: String,
  objective: String,
  assessment: String,
  plan: String,
  editedByUserId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  editedByRole: String,
  editedAt: Date
}, { _id: false });

const ConsultationEventSchema = new mongoose.Schema({
  patientId: { type: mongoose.Schema.Types.ObjectId, ref: 'Patient', required: true },
  doctorId: { type: mongoose.Schema.Types.ObjectId, ref: 'Doctor' },
  createdByRole: { type: String },
  createdByUserId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  audioPath: { type: String },
  transcript: { type: String },
  soap: {
    current: SoapVersionSchema,
    history: [SoapVersionSchema]
  },
  status: { type: String, default: 'UNVERIFIED' }, // UNVERIFIED | VERIFIED_DOCTOR | VERIFIED_STAFF | IGNORED_BY_DOCTOR
  prescriptionId: { type: mongoose.Schema.Types.ObjectId, ref: 'PrescriptionEvent' }
}, { timestamps: true });

module.exports = mongoose.models.ConsultationEvent || mongoose.model('ConsultationEvent', ConsultationEventSchema);



backend/./src/modules/patients/patients.routes.js:
const express = require('express');
const router = express.Router();
const ctrl = require('./patients.controller');

router.get('/', ctrl.list);
router.get('/:id', ctrl.get);
router.post('/', ctrl.create);

module.exports = router;



backend/./src/modules/patients/patients.service.js:
let store = [];
exports.list = async () => store;
exports.getById = async (id) => store.find(x=>x._id===id);
exports.create = async (data) => {
  const obj = { ...data, _id:(Math.random()*1e18).toString(36) };
  store.push(obj); return obj;
};



backend/./src/modules/patients/patients.controller.js:
const svc = require('./patients.service');
exports.list = async (req,res) => res.json(await svc.list());
exports.get = async (req,res) => {
  const p = await svc.getById(req.params.id);
  if (!p) return res.status(404).json({ error: 'Patient not found' });
  res.json(p);
};
exports.create = async (req,res) => res.status(201).json(await svc.create(req.body));



backend/./src/modules/auth/auth.routes.js:
const express = require('express');
const router = express.Router();
const { adminLogin, login } = require('./auth.controller');

router.post('/login', login);

// export
module.exports = router;



backend/./src/modules/auth/auth.service.js:
// backend/src/modules/auth/auth.service.js
// Service layer for auth-related business logic.
// Currently minimal, but ready for future expansion.

const User = require('../../db/models/User');
const bcrypt = require('bcryptjs');

/**
 * Find a user by email.
 */
async function findUserByEmail(email) {
  return await User.findOne({ email });
}

/**
 * Verify that a plaintext password matches a stored bcrypt hash.
 */
async function verifyPassword(plain, hash) {
  return await bcrypt.compare(plain, hash);
}

/**
 * Hash a plaintext password (for future "create user" admin flows).
 */
async function hashPassword(plain) {
  return await bcrypt.hash(plain, 10);
}

module.exports = {
  findUserByEmail,
  verifyPassword,
  hashPassword,
};



backend/./src/modules/auth/auth.controller.js:
const jwt = require('jsonwebtoken');
const User = require('../../db/models/User'); // ensure this model exists
const bcrypt = require('bcryptjs');

const adminLogin = async (req, res) => {
  const { apiKey } = req.body;
  if (!apiKey) return res.status(400).json({ error: 'apiKey required' });
  if (apiKey !== process.env.ADMIN_API_KEY) {
    return res.status(401).json({ error: 'Invalid admin key' });
  }

  const payload = { sub: 'admin', role: 'admin', name: 'UHI Admin' };
  const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '8h' });
  return res.json({ token, role: 'admin' });
};

const login = async (req, res) => {
  const { email, password } = req.body;
  if (!email || !password) return res.status(400).json({ error: 'email & password required' });
  const user = await User.findOne({ email });
  if (!user) return res.status(401).json({ error: 'Invalid credentials' });
  const ok = await bcrypt.compare(password, user.passwordHash);
  if (!ok) return res.status(401).json({ error: 'Invalid credentials' });
  const payload = { sub: user._id.toString(), role: user.role, name: user.name };
  const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '8h' });
  res.json({ token, role: user.role, userId: user._id });
};

module.exports = { adminLogin, login };



backend/./src/modules/lhp/lhp.controller.js:
// backend/src/modules/lhp/lhp.controller.js
const svc = require('./lhp.service');
const ConsultationEvent = require('../../db/models/ConsultationEvent');

exports.getLhpForPatient = async (req, res) => {
  const patientId = req.params.patientId;
  const requester = req.user || null;

  // require auth
  if (!requester) return res.status(401).json({ error: 'Unauthorized' });

  // If doctor, ensure they have consulted the patient before allowing access to full LHP
  if (requester.role === 'doctor') {
    // require doctorId is present on the token
    if (!requester.doctorId) return res.status(403).json({ error: 'Forbidden' });

    const consulted = await ConsultationEvent.findOne({
      doctorId: requester.doctorId,
      patientId
    }).lean();

    if (!consulted) {
      // deny full LHP access ‚Äî but you may allow limited/basic LHP fields here if desired
      return res.status(403).json({ error: 'Doctor cannot access this LHP' });
    }
  }

  // For admin/staff/self or verified doctor, return data
  const data = await svc.getForPatient(patientId);
  res.json(data);
};

exports.createSuggestion = async (req, res) => {
  const patientId = req.params.patientId;
  const requester = req.user || null;
  if (!requester) return res.status(401).json({ error: 'Unauthorized' });

  // only doctor/staff/admin can create suggestion ‚Äî doctor must be treating this patient
  if (requester.role === 'doctor') {
    if (!requester.doctorId) return res.status(403).json({ error: 'Forbidden' });
    const consulted = await ConsultationEvent.findOne({
      doctorId: requester.doctorId,
      patientId
    }).lean();
    if (!consulted) return res.status(403).json({ error: 'Doctor cannot add suggestion for this patient' });
  } else if (requester.role !== 'staff' && requester.role !== 'admin') {
    return res.status(403).json({ error: 'Forbidden' });
  }

  const s = await svc.createSuggestion(patientId, req.body);
  res.status(201).json(s);
};



backend/./src/modules/lhp/lhp.service.js:
let store = {};
exports.getForPatient = async (patientId) => store[patientId] || { patientId, sections: [] };
exports.createSuggestion = async (patientId, payload) => {
  const entry = { id: (Math.random()*1e18).toString(36), patientId, payload, createdAt: new Date() };
  store[patientId] = store[patientId] || { patientId, sections: [] };
  store[patientId].sections.push(entry);
  return entry;
};



backend/./src/modules/lhp/lhp.routes.js:
// backend/src/modules/lhp/lhp.routes.js
const express = require('express');
const router = express.Router();
const controller = require('./lhp.controller');
const { requireAuth } = require('../../middleware/authMiddleware');

router.get('/:patientId', requireAuth, controller.getLhpForPatient);
router.post('/:patientId/suggestions', requireAuth, controller.createSuggestion);

module.exports = router;



backend/./src/modules/doctors/doctors.routes.js:
const express = require('express');
const router = express.Router();
const ctrl = require('./doctors.controller');

router.get('/', ctrl.list);
router.get('/:id', ctrl.get);
router.post('/', ctrl.create);

module.exports = router;



backend/./src/modules/doctors/doctors.controller.js:
const svc = require('./doctors.service');
exports.list = async (req,res) => res.json(await svc.list());
exports.get = async (req,res) => {
  const d = await svc.getById(req.params.id);
  if (!d) return res.status(404).json({ error: 'Doctor not found' });
  res.json(d);
};
exports.create = async (req,res) => res.status(201).json(await svc.create(req.body));



backend/./src/modules/doctors/doctors.service.js:
let store = [];
exports.list = async () => store;
exports.getById = async (id) => store.find(x=>x._id===id);
exports.create = async (data) => {
  const obj = { ...data, _id: (Math.random()*1e18).toString(36) };
  store.push(obj); return obj;
};



backend/./src/modules/consultations/consultations.service.js:
let store = [];
exports.list = async () => store;
exports.getById = async (id) => store.find(s=>s._id===id);
exports.create = async (data) => {
  const obj = { ...data, _id: (Math.random()*1e18).toString(36), createdAt: new Date() };
  store.push(obj); return obj;
};
exports.update = async (id, data) => {
  const i = store.findIndex(s=>s._id===id);
  if (i<0) return null;
  store[i] = { ...store[i], ...data }; return store[i];
};



backend/./src/modules/consultations/consultations.controller.js:
const svc = require('./consultations.service');

exports.list = async (req, res) => res.json(await svc.list());
exports.get = async (req, res) => {
  const item = await svc.getById(req.params.id);
  if (!item) return res.status(404).json({ error: 'Not found' });
  res.json(item);
};
exports.create = async (req, res) => res.status(201).json(await svc.create(req.body));
exports.uploadAudio = async (req, res) => {
  // placeholder: actual file handling via uploadMiddleware
  res.json({ message: 'audio received (placeholder)' });
};
exports.verify = async (req, res) => res.json({ message: 'verified (placeholder)' });



backend/./src/modules/consultations/consultations.routes.js:
const express = require('express');
const router = express.Router();
const ctrl = require('./consultations.controller');

router.get('/', ctrl.list);
router.get('/:id', ctrl.get);
router.post('/', ctrl.create);
router.post('/:id/upload-audio', ctrl.uploadAudio); // placeholder
router.put('/:id/verify', ctrl.verify);

module.exports = router;



backend/./src/modules/users/users.service.js:
// backend/src/modules/users/users.service.js
const mongoose = require('mongoose');
const User = require('../../db/models/User');
const bcrypt = require('bcryptjs');

// domain models
const Doctor = require('../../db/models/Doctor');
const Patient = require('../../db/models/Patient');
const Staff = require('../../db/models/Staff');

async function createDoctorIfNeeded(data, session) {
  if (data.doctorId) return { id: data.doctorId, created: false };

  if (data.doctor && typeof data.doctor === 'object') {
    const doc = {
      name: data.doctor.name,
      specialization: data.doctor.specialization || undefined,
      registrationNumber: data.doctor.registrationNumber || undefined
    };
    if (!doc.name) throw new Error('doctor.name is required when creating a doctor');

    const created = await Doctor.create([doc], session ? { session } : undefined);
    const createdId = Array.isArray(created) ? created[0]._id : created._id;
    return { id: createdId, created: true };
  }

  throw new Error('doctorId or doctor object required for role doctor');
}

async function createPatientIfNeeded(data, session) {
  if (data.patientId) return { id: data.patientId, created: false };

  if (data.patient && typeof data.patient === 'object') {
    const doc = {
      patientCode: data.patient.patientCode || `P-${Date.now().toString().slice(-6)}`,
      name: data.patient.name,
      age: data.patient.age,
      gender: data.patient.gender,
      phone: data.patient.phone
    };
    if (!doc.patientCode || !doc.name) throw new Error('patient.patientCode and patient.name are required when creating a patient');

    const created = await Patient.create([doc], session ? { session } : undefined);
    const createdId = Array.isArray(created) ? created[0]._id : created._id;
    return { id: createdId, created: true };
  }

  throw new Error('patientId or patient object required for role patient');
}

async function createStaffIfNeeded(data, session) {
  if (data.staffId) return { id: data.staffId, created: false };

  if (data.staff && typeof data.staff === 'object') {
    const doc = {
      name: data.staff.name,
      roleDescription: data.staff.roleDescription || undefined
    };
    if (!doc.name) throw new Error('staff.name is required when creating staff');

    const created = await Staff.create([doc], session ? { session } : undefined);
    const createdId = Array.isArray(created) ? created[0]._id : created._id;
    return { id: createdId, created: true };
  }

  throw new Error('staffId or staff object required for role staff');
}

exports.list = async () => {
  // Admin-only usage expected. Returns users without passwordHash.
  return await User.find({}, '-passwordHash').lean();
};

exports.getById = async (id) => {
  return await User.findById(id, '-passwordHash').lean();
};

exports.create = async (data) => {
  if (!data || !data.email || !data.password) {
    throw new Error('email and password are required');
  }

  // Prevent creation of additional admins unless explicitly allowed
  if (data.role && data.role === 'admin' && process.env.ALLOW_ADMIN_CREATE !== 'true') {
    throw new Error('Creating admin users via API is disabled. Use env ALLOW_ADMIN_CREATE=true to allow.');
  }

  // ensure unique email
  const existing = await User.findOne({ email: data.email });
  if (existing) throw new Error('email already exists');

  const role = data.role || 'patient';

  // Attempt to use a mongoose session/transaction where possible
  let session = null;
  let usingTransaction = false;
  try {
    session = await mongoose.startSession();
    try {
      session.startTransaction();
      usingTransaction = true;
    } catch (txErr) {
      usingTransaction = false;
    }
  } catch (sessErr) {
    session = null;
    usingTransaction = false;
  }

  const createdDomain = { doctorId: null, patientId: null, staffId: null };

  try {
    let doctorInfo, patientInfo, staffInfo;
    if (role === 'doctor') {
      doctorInfo = await createDoctorIfNeeded(data, usingTransaction ? session : null);
      if (doctorInfo.created) createdDomain.doctorId = doctorInfo.id;
    } else if (role === 'patient') {
      patientInfo = await createPatientIfNeeded(data, usingTransaction ? session : null);
      if (patientInfo.created) createdDomain.patientId = patientInfo.id;
    } else if (role === 'staff') {
      staffInfo = await createStaffIfNeeded(data, usingTransaction ? session : null);
      if (staffInfo.created) createdDomain.staffId = staffInfo.id;
    }

    const passwordHash = await bcrypt.hash(data.password, 10);

    const userDoc = {
      email: data.email,
      passwordHash,
      role,
      name: data.name || '',
      doctorId: doctorInfo?.id || undefined,
      patientId: patientInfo?.id || undefined,
      staffId: staffInfo?.id || undefined
    };

    const createdUsers = await User.create([userDoc], usingTransaction ? { session } : undefined);
    const createdUser = Array.isArray(createdUsers) ? createdUsers[0] : createdUsers;

    if (usingTransaction && session) {
      await session.commitTransaction();
    }

    const out = createdUser.toObject();
    delete out.passwordHash;
    return out;
  } catch (err) {
    if (usingTransaction && session) {
      try { await session.abortTransaction(); } catch (e) { /* ignore */ }
    } else {
      try {
        if (createdDomain.doctorId) await Doctor.findByIdAndDelete(createdDomain.doctorId).exec();
        if (createdDomain.patientId) await Patient.findByIdAndDelete(createdDomain.patientId).exec();
        if (createdDomain.staffId) await Staff.findByIdAndDelete(createdDomain.staffId).exec();
      } catch (rbErr) {
        console.error('Rollback error:', rbErr);
      }
    }
    throw err;
  } finally {
    if (session) session.endSession();
  }
};

exports.update = async (id, data) => {
  if (data.role === 'admin' && process.env.ALLOW_ADMIN_CREATE !== 'true') {
    // disallow promoting to admin via update unless explicitly allowed
    throw new Error('Modifying role to admin via API is disabled.');
  }
  if (data.password) {
    data.passwordHash = await bcrypt.hash(data.password, 10);
    delete data.password;
  }
  const updated = await User.findByIdAndUpdate(id, data, { new: true, select: '-passwordHash' }).lean();
  return updated;
};

exports.remove = async (id) => {
  await User.findByIdAndDelete(id);
  return;
};



backend/./src/modules/users/users.controller.js:
// backend/src/modules/users/users.controller.js
const service = require('./users.service');

// -----------------------
// Redaction Helper
// -----------------------
function redactForRequester(targetUser, requester) {
  if (!requester) {
    return { _id: targetUser._id, role: targetUser.role, name: targetUser.name || null };
  }

  // ADMIN ‚Üí full access
  if (requester.role === 'admin') return targetUser;

  // SELF ‚Üí full access
  if (String(requester.sub) === String(targetUser._id)) return targetUser;

  // DOCTOR accessing PATIENT
  if (requester.role === 'doctor' && targetUser.role === 'patient') {
    return {
      _id: targetUser._id,
      role: targetUser.role,
      name: targetUser.name,
      patientId: targetUser.patientId,
      phone: targetUser.phone || null,
      gender: targetUser.gender || null,
      age: targetUser.age || null,
      createdAt: targetUser.createdAt
    };
  }

  // STAFF ‚Üí very limited info
  if (requester.role === 'staff') {
    return {
      _id: targetUser._id,
      role: targetUser.role,
      name: targetUser.name || null
    };
  }

  // DEFAULT
  return { _id: targetUser._id, role: targetUser.role, name: targetUser.name };
}

// -----------------------
// LIST USERS (ADMIN ONLY)
// -----------------------
exports.listUsers = async (req, res) => {
  if (!req.user || req.user.role !== 'admin') {
    return res.status(403).json({ error: 'Forbidden: Admin only' });
  }

  const items = await service.list();
  res.json({ count: items.length, items });
};

// -----------------------
// GET USER (Role Safe)
// -----------------------
exports.getUser = async (req, res) => {
  const target = await service.getById(req.params.id);
  if (!target) return res.status(404).json({ error: 'User not found' });

  const safe = redactForRequester(target, req.user);
  return res.json(safe);
};

// -----------------------
// CREATE USER (ADMIN)
// -----------------------
exports.createUser = async (req, res) => {
  if (!req.user || req.user.role !== 'admin') {
    return res.status(403).json({ error: 'Forbidden: Admin only' });
  }

  try {
    const out = await service.create(req.body);
    res.status(201).json(out);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

// -----------------------
// UPDATE USER (admin or self)
// -----------------------
exports.updateUser = async (req, res) => {
  const isSelf = req.user && String(req.user.sub) === String(req.params.id);

  if (!req.user || (req.user.role !== 'admin' && !isSelf)) {
    return res.status(403).json({ error: 'Forbidden' });
  }

  try {
    const updated = await service.update(req.params.id, req.body);
    res.json(updated);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

// -----------------------
// DELETE USER (Admin only)
// -----------------------
exports.deleteUser = async (req, res) => {
  if (!req.user || req.user.role !== 'admin') {
    return res.status(403).json({ error: 'Forbidden' });
  }

  await service.remove(req.params.id);
  res.status(204).end();
};



backend/./src/modules/users/users.routes.js:
// backend/src/modules/users/users.routes.js
const express = require('express');
const router = express.Router();
const controller = require('./users.controller');
const { requireAuth } = require('../../middleware/authMiddleware');
// const { requireRole } = require('../../middleware/roleMiddleware'); // optionally used elsewhere

router.use(requireAuth); // ensure all user routes are authenticated

router.get('/', controller.listUsers); // admin only inside controller
router.get('/:id', controller.getUser);
router.post('/', controller.createUser); // protected in controller (admin)
router.put('/:id', controller.updateUser);
router.delete('/:id', controller.deleteUser);

module.exports = router;



backend/./src/modules/staff/staff.service.js:
/**
 * In-memory stub for staff module.
 * Replace later with real DB using the Staff mongoose model.
 */

let store = [];

// GET all staff
exports.list = async () => store;

// GET staff by ID
exports.getById = async (id) => store.find(item => item._id === id);

// CREATE staff
exports.create = async (data) => {
  const newItem = {
    ...data,
    _id: (Math.random() * 1e18).toString(36),
    createdAt: new Date()
  };
  store.push(newItem);
  return newItem;
};

// UPDATE staff
exports.update = async (id, data) => {
  const index = store.findIndex(item => item._id === id);
  if (index === -1) return null;

  store[index] = { ...store[index], ...data, updatedAt: new Date() };
  return store[index];
};

// DELETE staff
exports.remove = async (id) => {
  store = store.filter(item => item._id !== id);
  return;
};



backend/./src/modules/staff/staff.controller.js:
const service = require('./staff.service');

exports.listStaff = async (req, res) => {
  const items = await service.list();
  res.json({ count: items.length, items });
};

exports.getStaff = async (req, res) => {
  const item = await service.getById(req.params.id);
  if (!item) return res.status(404).json({ error: 'Staff not found' });
  res.json(item);
};

exports.createStaff = async (req, res) => {
  const created = await service.create(req.body);
  res.status(201).json(created);
};

exports.updateStaff = async (req, res) => {
  const updated = await service.update(req.params.id, req.body);
  if (!updated) return res.status(404).json({ error: 'Staff not found' });
  res.json(updated);
};

exports.deleteStaff = async (req, res) => {
  await service.remove(req.params.id);
  res.status(204).end();
};



backend/./src/modules/staff/staff.routes.js:
const express = require('express');
const router = express.Router();
const controller = require('./staff.controller');

// GET /api/staff
router.get('/', controller.listStaff);

// GET /api/staff/:id
router.get('/:id', controller.getStaff);

// POST /api/staff
router.post('/', controller.createStaff);

// PUT /api/staff/:id
router.put('/:id', controller.updateStaff);

// DELETE /api/staff/:id
router.delete('/:id', controller.deleteStaff);

module.exports = router;



backend/./src/modules/timeline/timeline.routes.js:
const express = require('express');
const router = express.Router();
const ctrl = require('./timeline.controller');

router.get('/patient/:patientId', ctrl.getTimelineForPatient);

module.exports = router;



backend/./src/modules/timeline/timeline.controller.js:
const svc = require('./timeline.service');

exports.getTimelineForPatient = async (req, res) => {
  const t = await svc.getForPatient(req.params.patientId);
  res.json(t);
};



backend/./src/modules/timeline/timeline.service.js:
let store = {};
exports.getForPatient = async (patientId) => store[patientId] || { patientId, events: [] };



backend/./src/modules/prescriptions/prescriptions.routes.js:
const express = require('express');
const router = express.Router();
const ctrl = require('./prescriptions.controller');

router.get('/', ctrl.list);
router.get('/:id', ctrl.get);
router.post('/', ctrl.create);
router.post('/:id/upload-image', ctrl.uploadImage);

module.exports = router;



backend/./src/modules/prescriptions/prescriptions.controller.js:
const svc = require('./prescriptions.service');
exports.list = async (req,res) => res.json(await svc.list());
exports.get = async (req,res) => {
  const p = await svc.getById(req.params.id);
  if (!p) return res.status(404).json({ error: 'Prescription not found' });
  res.json(p);
};
exports.create = async (req,res) => res.status(201).json(await svc.create(req.body));
exports.uploadImage = async (req,res) => res.json({ message: 'image upload placeholder' });



backend/./src/modules/prescriptions/prescriptions.service.js:
let store=[];
exports.list = async()=>store;
exports.getById = async(id)=>store.find(s=>s._id===id);
exports.create = async(data)=>{ const o={...data,_id:(Math.random()*1e18).toString(36)}; store.push(o); return o; };



backend/./src/modules/notifications/notifications.controller.js:
const svc = require('./notifications.service');

exports.listForUser = async (req, res) => res.json(await svc.listForUser(req.params.userId));
exports.sendNotification = async (req, res) => res.json(await svc.send(req.body));



backend/./src/modules/notifications/notifications.routes.js:
const express = require('express');
const router = express.Router();
const ctrl = require('./notifications.controller');

router.get('/user/:userId', ctrl.listForUser);
router.post('/send', ctrl.sendNotification);

module.exports = router;



backend/./src/modules/notifications/notifications.service.js:
let store = {};
exports.listForUser = async userId => store[userId] || [];
exports.send = async payload => {
  const id = (Math.random()*1e18).toString(36);
  const entry = { id, ...payload, createdAt: new Date() };
  if (payload.to) {
    store[payload.to] = store[payload.to] || [];
    store[payload.to].push(entry);
  }
  return entry;
};



backend/./src/routes/index.js:
// backend/src/routes/index.js
const express = require('express');
const path = require('path');

const router = express.Router();

function tryRequire(modPath) {
  try {
    const required = require(modPath);
    return required;
  } catch (err) {
    console.warn(`routes: failed to require ${modPath} ‚Äî ${err.message}`);
    return null;
  }
}

function mountIfRouter(mountPath, modPath) {
  const mod = tryRequire(modPath);
  if (!mod) return;

  // module could export router directly, or export an object with router property
  const candidate = mod.router || mod;

  // router objects usually have 'use' or 'stack' or 'handle'
  const looksLikeRouter = candidate && (
    typeof candidate === 'function' ||
    typeof candidate.use === 'function' ||
    Array.isArray(candidate.stack) ||
    typeof candidate.handle === 'function'
  );

  if (looksLikeRouter) {
    router.use(mountPath, candidate);
    console.log(`routes: mounted ${modPath} @ ${mountPath}`);
  } else {
    console.warn(`routes: skipping ${modPath} ‚Äî exported value is not an express router`);
  }
}

// Mount known modules (if some modules are missing or empty, they will be skipped)
// Edit this list as modules are added/removed
mountIfRouter('/auth', path.join(__dirname, '..', 'modules', 'auth', 'auth.routes'));
mountIfRouter('/users', path.join(__dirname, '..', 'modules', 'users', 'users.routes'));
mountIfRouter('/patients', path.join(__dirname, '..', 'modules', 'patients', 'patients.routes'));
mountIfRouter('/doctors', path.join(__dirname, '..', 'modules', 'doctors', 'doctors.routes'));
mountIfRouter('/staff', path.join(__dirname, '..', 'modules', 'staff', 'staff.routes'));
mountIfRouter('/consultations', path.join(__dirname, '..', 'modules', 'consultations', 'consultations.routes'));
mountIfRouter('/prescriptions', path.join(__dirname, '..', 'modules', 'prescriptions', 'prescriptions.routes'));
mountIfRouter('/lhp', path.join(__dirname, '..', 'modules', 'lhp', 'lhp.routes'));
mountIfRouter('/timeline', path.join(__dirname, '..', 'modules', 'timeline', 'timeline.routes'));
mountIfRouter('/notifications', path.join(__dirname, '..', 'modules', 'notifications', 'notifications.routes'));

// default health / info route on the router (optional)
router.get('/', (req, res) => res.json({ ok: true, routes: 'see server logs for mounted routes' }));

module.exports = router;



backend/./src/app.js:
const express = require('express');
const cors = require('cors');
const routes = require('./routes');
const { errorHandler } = require('./middleware/errorHandler');

const app = express();

app.use(cors({ origin: process.env.FRONTEND_URL || true }));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// static uploads (serve for demo)
app.use('/uploads', express.static('src/uploads'));

app.use('/api', routes);

// error handler last
app.use(errorHandler);

app.get('/health', (req,res)=> res.json({ok:true, time: new Date()}));



module.exports = app;



backend/./src/services/aiService/index.js:
const mode = process.env.AI_MODE || 'mock';
if (mode === 'live') {
  module.exports = require('./live');
} else {
  module.exports = require('./mock');
}



backend/./src/services/aiService/mock.js:
const fs = require('fs');
const path = require('path');

function read(template) {
  try {
    const p = path.join(__dirname, 'templates', template);
    return JSON.parse(fs.readFileSync(p, 'utf8'));
  } catch (e) {
    return null;
  }
}

async function transcribeAudio(audioPath) {
  // return sample transcript text
  const obj = read('mock_transcript.json');
  return obj?.text || 'Patient complains of cough and fever for 3 days.';
}

async function generateSOAP(transcript) {
  const obj = read('mock_soap.json');
  return obj;
}

async function extractMeds(imagePath) {
  const obj = read('mock_meds.json');
  return obj.medications || [];
}

async function generateLhpSuggestionsFromConsultation(consultation) {
  const obj = read('mock_lhp_suggestions.json');
  return obj.suggestions || [];
}

module.exports = {
  transcribeAudio,
  generateSOAP,
  extractMeds,
  generateLhpSuggestionsFromConsultation,
  generateLhpSuggestionsFromPrescription: generateLhpSuggestionsFromConsultation
};



backend/./src/services/aiService/templates/mock_transcript.json:
{ "text": "Patient: I have had a cough and fever for three days. No chest pain. Taking paracetamol occasionally." }



backend/./src/services/aiService/templates/mock_lhp_suggestions.json:
{
  "suggestions": [
    {"section":"CURRENT_MEDICATION","proposedEntry":{"name":"Paracetamol","dosage":"500mg","isCurrent":true},"note":"From prescription X"}
  ]
}



backend/./src/services/aiService/templates/mock_meds.json:
{
  "medications": [
    {"name":"Paracetamol","dosage":"500mg","frequency":"TID","duration":"5 days","route":"oral","instructions":"after food","isCurrent":true}
  ]
}



backend/./src/services/aiService/templates/mock_soap.json:
{
  "subjective": "Patient reports cough and fever x3 days.",
  "objective": "Afebrile at exam, lungs clear. Vitals stable.",
  "assessment": "Likely viral upper respiratory infection.",
  "plan": "Symptomatic care. Paracetamol PRN. Return if worsening."
}



backend/./src/services/aiService/live.js:



